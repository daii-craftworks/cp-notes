# mod 分類 × 貪欲 MEX 構築（Mod-Grouped Greedy for MEX)

> 値に (+k) / (-k) を何度でも足し引きできる、または「操作で値が (\bmod\ k) の同値類から出ない」タイプの問題を、剰余クラスの **在庫管理** に落とし込んで MEX を 0→1→2… と貪欲に構築するパターン。

---

## 1. いつ使える？（適用条件）

* 操作が「値を (\pm k) ずつ動かせる」「(k) 周期で同値（剰余が不変）」など **周期性** をもつ。
* 目標が **MEX**（最小の欠番）や 0 から連続的に埋めたい値である。
* 各要素は「その剰余クラスの任意の値」に変換できる（= 剰余以外の拘束がない）。

> このとき、各要素は「(r = a_i \bmod k) の箱」に入り、箱の **個数（在庫）** だけが本質になる。

---

## 2. 基本アイデア

1. 各要素を (r = a_i \bmod k) に写して **頻度** (\text{cnt}[r]) を数える。
2. MEX を (m=0,1,2,\dots) と増やす。
3. 必要な剰余は (r = m \bmod k)。(\text{cnt}[r] > 0) なら 1 個消費（(\text{cnt}[r]--)）して次へ。(\text{cnt}[r] = 0) なら **そこで停止**、答えは (m)。

### なぜ正しい？（直観）

* (m) を実現するには (m\bmod k) の剰余が必須。別剰余からは作れない。
* 0→1→2… と順に見る貪欲は、各段階での必要条件を満たせる限り最適に延びる（将来のために温存しても得をしない）。

---

## 3. 擬似コード / 実装テンプレ

### Python
```python
from collections import Counter
from typing import List

def mod_mex(nums: List[int], k: int) -> int:
    # Python の % は負数も 0..k-1 に入る
    cnt = Counter(x % k for x in nums)
    mex = 0
    while cnt[mex % k] > 0:
        cnt[mex % k] -= 1
        mex += 1
    return mex
```

---

## 4. 例題（LeetCode 2598）

* `nums = [1,-10,7,13,6,8], k = 5` → 答え `4`
* `nums = [3,0,3,2,4,2,1,1,0,4], k = 5` → 各剰余が 2 個ずつ → `0..9` を全て構成 → 答え `10`

---

## 5. よくある落とし穴

* **set に入れてしまう**：頻度が消えて誤答になる。
* **abs(n) % k を使う**：Python は負数でも `n % k` が 0..k-1 なので `abs` 不要（むしろ危険）。
* **順序未定の走査**：`set` → `list` など順序は関係ない。重要なのは在庫の減算。

---

## 6. 複雑度

* 前処理：(O(n))（カウント）
* 本体：高々答え回数だけループ。実質 (O(n))。空間 (O(k))。

---

## 7. 変種・拡張

* **複数の操作幅**：ただし「同じ剰余類を保つ」性質が壊れると不可。
* **MEX 以外**（例：0..T を作れる最大 (T)）：同じ在庫消費で判定可。
* **多重集合での MEX**：在庫管理＋貪欲がそのまま効く。

---

## 8. 確認チェックリスト
- [ ] 操作が剰余を保存することを確認したか？
- [ ] `cnt` は頻度（set ではない）で作ったか？
- [ ] Python ならそのまま `x % k` を使っているか？
- [ ] ループは `while cnt[mex % k]: mex += 1` の在庫消費になっているか？

---
