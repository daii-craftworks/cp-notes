# 学習ログ
# 2025-11-25
## 今日やったこと
- LeetCode1015: “巨大な数を作らずに mod 更新だけで扱う”
## 気付き
```
レピュニットは末尾が必ず 1（奇数）
→ 偶数の倍数にならない
末尾が 1
→ 5 の倍数（末尾 0 or 5）にならない
if k % 2 == 0 or k % 5 == 0:
    return -1

mod k の更新は：
rem = 0 からはじめて、
rem = (rem * 10 + 1) % k
```


# 2025-11-23
## 今日やったこと
- LeetCode1262: mod DP（余り DP） による「最大和を作る」
## 気付き
```python
部分集合の和について
“和 % M が指定条件を満たす” ような最大／最小値を求めたいとき
M が小さい（典型：M = 2, 3, 5 など）
「和全体を全部列挙する DP（O(N * sum))」は大きすぎて無理
→ **余りだけ持てば十分！**というケース
(初期値　m = 3)
dp = [0, -inf, -inf]
for x in nums:
    ndp = dp[:]
    for r in 0..M-1:
        if dp[r] is valid:
            new_sum = dp[r] + x
            nr = new_sum % M
            ndp[nr] = max(ndp[nr], new_sum)

    dp = ndp
return dp[0]
```


# 2025-11-20
## 今日やったこと
- LeetCode757: 区間 × 貪欲：各区間に少なくとも K 点を含める
## 気付き
```
1番目の要素をソートして、0番目の要素をソートする
sort(key=lambda x: (x[1], -x[0]))
```


# 2025-11-19
## 今日やったこと
- LeetCode2154: 要素の存在確認
## 気付き
```
dic と set は 算量的には同じ です（どちらも平均 O(1)）
```


# 2025-11-11
## 今日やったこと
- LeetCode474: ナップサック　→　DP
## 気付き
```
チェック項目／説明
・選ぶ/選ばない構造／部分集合を作る
・制約あり／m個までの0、n個までの1
・最大化/最小化／最大サイズを求める
・コストと価値／cost=(#0,#1), value=1
・順序無関係／集合問題
以上がすべてあてはまると☞☞☞ナップサック

⭐一つしか選べないVer.のDPは，後ろからまわさないといけない！
```


# 2025-11-07
## 今日やったこと
- LeetCode2528: ・最小値の最大化，差分配列
## 気付き
```
⭐⭐⭐「最小値の最大化」「最大値の最小化」→ 二分探索を考える！
def solve():
    left, right = 最小値, 最大値
    answer = left
    
    while left <= right:
        mid = (left + right) // 2
        if can_achieve(mid):  # mid が達成可能か？
            answer = mid
            left = mid + 1    # もっと大きい値を試す
        else:
            right = mid - 1   # 小さい値にする
    
    return answer

⭐⭐⭐差分配列（Difference Array） 
範囲更新を O(1) で行う
# 通常: O(範囲の長さ)
for i in range(L, R+1):
    arr[i] += value

# 差分配列: O(1)
diff[L] += value
diff[R+1] -= value
# 後で累積和を取る: O(n)

**使いどころ:**
- 範囲に一定値を加算/減算
- 複数回の範囲更新 → 最後に累積和
```

# 2025-11-04
## 今日やったこと
- LeetCode3318: 単純な問題
## 気付き
```
辞書(d)のソートを複数のキーで
d_sorted = sorted(d.items(), key=lambda kv: (kv[1], kv[0]), reverse=True)
```




# 2025-11-03
## 今日やったこと
- LeetCode1578: 隣接要素の比較による一括最適化（One-pass greedy on consecutive groups）
## 気付き
```
for 要素 in シーケンス:
    if 状態が変わった: 状態をリセット
    res += min(現在の値, 保持中の最大)
    保持中の最大 = max(保持中の最大, 現在の値)
```



# 2025-11-02
## 今日やったこと
- LeetCode2257: 二次元配列の探索
## 気付き
```
for r in range(m):
        on = False
        for c in range(n):
                if grid[r][c] == WALL:
                    on = False
                elif grid[r][c] == GUARD:
                    on = True
                else:
                    if on:
                        guarded[r][c] = True
```
・このような形をとれば、捜査できる


# 2025-11-01
## 今日やったこと
- LeetCode3217: pythonの参照先の理解が必要な問題
## 気付き
```
・a = [1,2,3]
　b = a
　（実際のモデル）
　┌────┐
　│ a  │────────────┐
　└────┘            │
 　                 ▼
  　             ┌─────────┐
   　            │ [1,2,3] │ ← オブジェクト（実体）
   　            └─────────┘
                   ▲
 ┌────┐            │
 │ b  │────────────┘
 └────┘
・浅いコピー
a = [[P], [Q]]
b = copy.copy(a)
a ──▶ [ * ]──▶ [P]
       │
       └──▶ [Q]

b ──▶ [ ** ]──▶ [P]
        │
        └──▶ [Q]
よって、b.append([R])をすると
a ──▶ [ * ]──▶ [P]
       │
       └──▶ [Q]

b ──▶ [ ** ]──▶ [P]
        │
        ├──▶ [Q]
        └──▶ [R]   👈 appendで新しい枝を追加
```

# 2025-10-31
## 今日やったこと
- LeetCode3289: in-place countingを使用する問題
## 気付き
```
・idx = nums[i] % n
　nums[idx] += n
  とすれば、
　count = nums[i] // n　
　で出現回数を取得できる。ただし、配列内の各要素が必ず 0 ≤ nums[i] < n
```

# 2025-10-30
## 今日やったこと
- LeetCode1526: セグメントツリーの使用が推奨される問題
## 気付き
・イマイチ、セグメントツリーの実装方法がわからない

# 2025-10-29
## 今日やったこと
- LeetCode3370: 全ビットが1の数＝メルセンヌ数
## 気付き
```
・tgt = 2 ** i - 1 でメルセンヌ数を作れる。
・n 以上の、最小の、メルセンヌ数は (1 << n.bit_length()) - 1 と書ける
```

# 2025-10-28
## 今日やったこと
- LeetCode3354: 累積和と全体和の関係を使って、左右のバランス条件を満たす点を探索する
## 気付き
・total = sum(A)
・左からの累積和：l
・右からの累積和：total - l


# 2025-10-25
## 今日やったこと
- LeetCode1716: 等差数列
## 気付き
・weeks, days = divmod(n, 7) のように書けば可読性が高い


# 2025-10-23
## 今日やったこと
- LeetCode3461: 文字列で与えられる数値の操作
## 気付き
・数値への変換は、 a = [int(ch) for ch in s]
・pop() は　O(1)


# 2025-10-22
## 今日やったこと
- LeetCode3347: スライドウィンドウ（値域ベース）＋頻度最大化
## 解法
・各要素 nums[i] は「可動区間 [nums[i]-k, nums[i]+k]」を持つ。
・目的は「同じ値 x に重ねられる区間を最大化すること」。
・よって、問題は区間 [nums[i]-k, nums[i]+k] が最も多く重なる点を探し、そのうち最大 numOperations 個を操作して重ねられるだけ重ねる
## アプローチ
・値域スライドウィンドウ
1. nums をソート。
2. 各値を「中心」と見て、範囲 [x-k, x+k] に入る要素数 window(x) を求める。
3. もともと x だった個数を cnt[x] として、freq(x) = min(window(x), cnt[x] + numOperations)
   上記の最大値が答え。
4. ただし目標値 x が配列外にある場合（たとえば [1,3] に対して x=2）もあり得るため、幅 2k の区間に入る最大個数も別途チェック。


# 2025-10-21
## 今日やったこと
- LeetCode3346: 与えられた区間 [L_i, R_i] のうち、同時にカバーされる最大本数を求める
## 解法
1. starts, ends を別配列に分けてソート
2. starts[i] <= ends[j] なら cur++、else cur--
3. max(cur) を取る


# 2025-10-19
## 今日やったこと
- LeetCode1625: 「状態空間探索（BFS/DFS）による文字列変換問題」かつ「辞書順最小化を目的とした探索問題」
- 文字列を操作しながら、BFS／DFSによる状態遷移探索を行う


# 2025-10-22
## 今日やったこと
- LeetCode3347: スライドウィンドウ（値域ベース）＋頻度最大化
## 解法
・各要素 nums[i] は「可動区間 [nums[i]-k, nums[i]+k]」を持つ。
n するより、探索中に ans = min(ans, cur)をした方が良い。
- 加算は % 10 を使う。str(int(n) + a)[-1] でも動きますが計算・文字列化が重い。((int(n) + a) % 10) にしてから chr/str に戻すのが定石。


# 2025-10-18
## 今日やったこと
- LeetCode3397: 「区間ごとに1点を選んで最大数を取る」タイプの区間スケジューリング問題の亜種
- イマイチ直感的に腑に落ちない部分はあるが、実装は難しくない
## 気付き
- 「区間を左端でソート → 取れる最小値で貪欲に詰める」タイプの問題は割と多い

# 2025-10-17
## 今日やったこと
- LeetCode3003: 「k 種類制約付き区間」問題の定番パターン
- とても難しい
## 気付き
- at most k distinct
- one-modification optimization
- greedy + DP + prefix/suffix analysis
- 基準解＋差分最大化
- 以上の複合体らしい。。
- → 以下の問題を順に解くと良いらしい。
- LeetCode 340 – Longest Substring with At Most K Distinct Characters（ウィンドウ基礎）
- LeetCode 159 – At Most Two Distinct（2 種限定の直感磨き）
- LeetCode 1004 – Max Consecutive Ones III（“at most k flips” 型で差分思考練習）

# 2025-10-16
## 今日やったこと
- LeetCode2598: modごとの在庫管理でMEXを貪欲に構築する
## 気付き
- 「値に ±value を足せる」「k ずつずらせる」など、周期性（mod value） が問題の核心。
- 「何をしても剰余は変わらない」ため、各剰余ごとにいくつ要素があるか（count） に集約できる。
- 求めたい値（MEXなど）を順に増やしていき、必要な剰余の在庫があれば消費、なければ終了。

# 2025-10-15
## 今日やったこと
- LeetCode3350: 隣接する増加部分配列（inc + 二分探索）

## 気付き
- inc[i] は「i始点の増加長」にすると判定が楽
- k の下限は 2（自分ルール）
