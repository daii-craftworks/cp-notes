# プロコン パターン帳（共通メモ）

📘 Pattern: レピュニット（111…1）を k で割り切れる最小長さ
🔍 問題タイプ
数論（mod の更新）
周期性（pigeonhole principle）
実際の数を構築せず “余りだけ” を扱う典型問題
🎯 タスク
「1 だけからなる正の整数」
1, 11, 111, 1111, ... のうち
k で割り切れる最短のものの“桁数（length）” を求める。
実際の値は巨大になるため、整数として扱ってはいけない
存在しなければ -1
❌ 不可能なケース（最重要）
k が 2 または 5 の倍数 → 絶対に無理
理由：
レピュニットは末尾が必ず 1（奇数）
→ 偶数の倍数にならない
末尾が 1
→ 5 の倍数（末尾 0 or 5）にならない
```python
if k % 2 == 0 or k % 5 == 0:
    return -1
```
🔁 余りの更新式（解法のコア）
レピュニット Rₙ の関係：
```
R₁ = 1
R₂ = 11 = 1*10 + 1
R₃ = 111 = 11*10 + 1
…
Rₙ₊₁ = Rₙ * 10 + 1
```
よって mod k の更新は：
```python
rem = (rem * 10 + 1) % k
```
だけで十分。

🐦 k 回で必ず判定できる理由（鳩ノ巣原理）
余りは 0〜k-1 の k 種類しかない。
長さ 1〜k の k 回分を見れば：
rem==0 が出れば終了（答え）
出なければ余りがループに入る → 今後 0 は絶対に出ない
したがって上限は k：
```python
for length in range(1, k+1):
    …
```

🧩 コードテンプレ（そのまま使える）
```python
def smallestRepunitDivByK(k: int) -> int:
    if k % 2 == 0 or k % 5 == 0:
        return -1

    rem = 0
    for length in range(1, k + 1):
        rem = (rem * 10 + 1) % k
        if rem == 0:
            return length

    return -1
```


## 単調性 × 二分探索
- 判定関数 ok(k) が単調（True→False）なら境界を二分探索
- 例: 隣接する2本の増加部分配列の最大長（LeetCode）

## 2-pointer / 累積 / DP / ヒープ探索 …（ここに追記）
---

## 付記：隣接する2本の増加部分配列（最大 k）
- 前計算：`inc[i] = i から始まる厳密増加の長さ`（右→左）
- 判定 `ok(k)`：ある `a ∈ [0, n-2k]` で `inc[a] >= k` かつ `inc[a+k] >= k`
- 二分探索で最大 k（**今回の実装では k の下限を 2** とした）
- 参照：`problems/leetcode/adjacent-increasing-two-blocks/README.md`

**注意**  
- 厳密増加は `<` 比較。  
- 上限は `k ≤ n//2`。  
- off-by-one：`a` の上限は `n - 2k`。  
- `n < 4` のときは 2 本の長さ2が置けないので 0。
---

## 付記：隣接する2本の増加部分配列（最大 k）
- 前計算：`inc[i] = i から始まる厳密増加の長さ`（右→左）
- 判定 `ok(k)`：ある `a ∈ [0, n-2k]` で `inc[a] >= k` かつ `inc[a+k] >= k`
- 二分探索で最大 k（**今回の実装では k の下限を 2** とした）
- 参照：`problems/leetcode/adjacent-increasing-two-blocks/README.md`

**注意**  
- 厳密増加は `<` 比較。  
- 上限は `k ≤ n//2`。  
- off-by-one：`a` の上限は `n - 2k`。  
- `n < 4` のときは 2 本の長さ2が置けないので 0。
